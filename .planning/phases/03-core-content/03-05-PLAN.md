---
phase: 03-core-content
plan: 05
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - docs/section-4/01-overview.mdx
  - docs/section-4/02-reading.md
  - docs/section-4/03-lab.md
  - docs/section-4/quiz.md
autonomous: true

must_haves:
  truths:
    - "Learner can read Module 4 content in 10-20 minutes and understand what service meshes provide and when they are warranted"
    - "Learner can follow the lab to evaluate service mesh options using a structured decision framework"
    - "Learner can articulate when a service mesh adds value vs unnecessary complexity"
    - "Learner can answer 12-15 quiz questions about service mesh concepts and decision criteria"
  artifacts:
    - path: "docs/section-4/02-reading.md"
      provides: "Service mesh decision framework with comparison"
      min_lines: 180
    - path: "docs/section-4/03-lab.md"
      provides: "Service mesh evaluation lab with decision framework exercise"
      min_lines: 200
    - path: "docs/section-4/quiz.md"
      provides: "12-15 service mesh quiz questions"
      min_lines: 120
  key_links:
    - from: "docs/section-4/03-lab.md"
      to: "docs/section-4/02-reading.md"
      via: "References decision framework from reading materials"
      pattern: "decision framework"
    - from: "docs/section-4/02-reading.md"
      to: "docs/section-4/03-lab.md"
      via: "Next Steps info box"
      pattern: "lab"
---

<objective>
Create complete Module 4: Service Mesh - an evaluation-focused module teaching learners when to adopt a service mesh and how to make that decision. Unlike Modules 1-3, this is a DECISION module: reading provides the framework, the lab is an evaluation exercise (with optional hands-on Linkerd exploration), and the quiz tests decision-making judgment.

Purpose: Service mesh is a crossroads decision in production readiness. Many teams adopt it prematurely (adding complexity without benefit) or too late (missing observability and security gaps). This module builds decision-making skills, not just technical skills.

Output: Complete Module 4 (overview, reading, lab, quiz) with 2-3 Mermaid diagrams, a decision framework, and an evaluation-style lab.
</objective>

<execution_context>
@/Users/gshah/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gshah/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-content/03-CONTEXT.md
@.planning/phases/03-core-content/03-RESEARCH.md
@.planning/phases/03-core-content/03-01-SUMMARY.md
@templates/content-template.md
@templates/lab-template.md
@templates/quiz-template.md
@templates/AUTHORING-GUIDE.md
@docs/section-4/01-overview.mdx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Module 4 reading materials with overview update and Mermaid diagrams</name>
  <files>
    docs/section-4/01-overview.mdx
    docs/section-4/02-reading.md
  </files>
  <action>
**1. Update docs/section-4/01-overview.mdx:**
Replace placeholder. Create proper module landing page:
- Title: "Module 4: Service Mesh"
- Frontmatter: sidebar_position: 1, title: "Overview"
- Metadata: Difficulty: Intermediate-Advanced, Estimated Time: 80 minutes (15 min reading + 45 min lab + 15 min quiz)
- "What You Will Learn" (5 items): What service mesh provides (mTLS, observability, traffic management), when to adopt a service mesh, Istio vs Linkerd comparison, decision framework for mesh adoption, optional hands-on with Linkerd
- "Prerequisites": Modules 0-3 completed (conceptual understanding), kubectl and kind installed. This module is evaluation-focused rather than implementation-focused.
- Overview: "You've added scheduling, autoscaling, and Gateway API to the Voting App. The next question isn't 'how to add a service mesh' - it is 'SHOULD you add one?' This module builds your decision-making muscle."

**2. Create docs/section-4/02-reading.md:**
Follow templates/content-template.md. Target: 12-18 minute read (~2500-3500 words). Conversational tone, no emojis.

Content structure:
- **Overview** (2-3 paragraphs): The service mesh question. Every production team eventually asks: "Do we need a service mesh?" The answer is nuanced - it depends on your scale, security requirements, and operational maturity. This module helps you make that decision for the Voting App and future projects.
- **What is a Service Mesh?** section:
  - Simple definition: A dedicated infrastructure layer for managing service-to-service communication
  - Sidecar pattern: proxy container injected alongside every app container
  - Include Mermaid sequence diagram: Service mesh traffic flow (Service A -> Sidecar Proxy A -> Sidecar Proxy B -> Service B, with control plane managing proxies)
  - What it provides: mTLS (encryption between services), observability (metrics, traces, logs per service), traffic management (retries, timeouts, circuit breaking), authorization policies
  - Analogy: "Think of a service mesh like a phone network. Without it, services yell across the room (plain HTTP). With it, they have private lines (mTLS), call logs (observability), and automatic redialing (retries)."
- **Istio vs Linkerd** section:
  - Istio: Feature-rich, complex, larger resource footprint, more configuration options, Envoy-based
  - Linkerd: Lightweight, simpler, smaller footprint, faster to learn, purpose-built Rust proxy
  - Include Mermaid comparison diagram or table: Side-by-side comparison covering: installation complexity, resource overhead, learning curve, feature set, community, CNCF status
  - Key difference: "Istio is a Swiss Army knife. Linkerd is a scalpel. Choose based on what you actually need, not what sounds impressive."
  - Info admonition: "Linkerd's lightweight approach adds 40-400% less latency than Istio. For many intermediate-complexity applications, it provides everything you need."
- **The Decision Framework** section:
  - Include Mermaid decision tree flowchart: "Do you need service mesh?" with branches:
    - Do you need mTLS between services? (regulatory, multi-tenant)
    - Do you need per-service observability? (more than basic metrics)
    - Do you have 10+ microservices? (complexity threshold)
    - Can your team manage the operational overhead?
    - Outcomes: "Yes, start with Linkerd" / "Not yet, revisit when you have more services" / "Use simpler alternatives (NetworkPolicy for security, Prometheus for observability)"
  - For the Voting App specifically: 5 services, simple communication pattern, development stage -> "Probably not yet. NetworkPolicy for security (Module 5), Prometheus for observability, and Gateway API for traffic management cover most needs."
  - Tip admonition: "Start without a service mesh. Add it when you have a specific problem it solves, not because it is on a technology radar."
- **Alternatives to Service Mesh** section:
  - mTLS: Use cert-manager + NetworkPolicies (simpler for small clusters)
  - Observability: Prometheus + Grafana + Jaeger (without mesh overhead)
  - Retries/timeouts: Application-level or Gateway API features
  - Authorization: Kubernetes RBAC + NetworkPolicies (Module 5)
  - Table mapping: "Need X? Consider Y before mesh"
- **When You DO Need a Service Mesh** section:
  - Regulatory compliance requiring mTLS everywhere
  - Multi-tenant clusters needing strict service isolation
  - 50+ microservices where manual configuration doesn't scale
  - Teams with platform engineering capacity
  - Caution admonition: "Adding a service mesh to a team of 3 managing 5 services is like hiring a personal assistant to manage your grocery list. It works, but the overhead exceeds the benefit."
- **Summary** with 5 bullet points
- **Further Reading**: Linkerd getting started, Istio docs, CNCF service mesh landscape
- Info admonition: "Next Steps - Apply the decision framework to the Voting App in the lab"
  </action>
  <verify>
    - Both files exist and are non-empty
    - `npm run build` succeeds
    - 02-reading.md contains at least 2 Mermaid diagram code blocks (traffic flow, decision tree)
    - 02-reading.md word count is 2500-3500 words
    - Content includes decision framework (not just technology comparison)
    - Content covers alternatives to service mesh
    - Content specifically evaluates Voting App's need
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 4 reading materials present a decision framework for service mesh adoption, comparing Istio/Linkerd, showing alternatives, with 2-3 Mermaid diagrams. Targeting 12-18 min read time.</done>
</task>

<task type="auto">
  <name>Task 2: Create Module 4 lab (evaluation exercise) and quiz</name>
  <files>
    docs/section-4/03-lab.md
    docs/section-4/quiz.md
  </files>
  <action>
**1. Create docs/section-4/03-lab.md:**
Follow templates/lab-template.md 8-section structure. Duration: 40-50 minutes. This is an EVALUATION lab, not a traditional implementation lab. Main tasks are analytical; optional challenge is hands-on Linkerd.

Title: "Lab: Evaluating Service Mesh for the Voting App"

- **Objectives** (5 items): Apply the service mesh decision framework, evaluate the Voting App's communication patterns, compare mesh vs non-mesh approaches for security and observability, document a formal adoption decision, (optional) install Linkerd and observe mesh behavior
- **Prerequisites**: Modules 0-3 completed (conceptual understanding of the Voting App architecture), KIND cluster running with base Voting App deployed
- **Setup**:
  - Ensure base Voting App is running (redeploy from examples/ if needed after Module 3 cleanup)
  - Verify all 5 components running: `kubectl get pods`
  - No special tools needed for evaluation tasks (just kubectl and a text editor)
- **Tasks** (4 main tasks + 1 challenge):
  - **Task 1: Map the Voting App Communication Patterns**:
    Use kubectl to discover service-to-service communication:
    `kubectl get services` - list all services
    `kubectl describe service vote` - check selectors and ports
    `kubectl exec deploy/vote -- env | grep -i redis` - check environment variables for connection strings
    Draw (or document) the communication graph: vote -> redis, worker -> redis, worker -> postgres, result -> postgres.
    Classify each connection: synchronous HTTP vs asynchronous queue, internal vs external, critical vs auxiliary.
    Deliverable: Written communication map with 5 connections documented.
  - **Task 2: Apply the Decision Framework**:
    Answer each decision framework question from the reading materials, applied to the Voting App:
    1. "Do we need mTLS?" - Evaluate: Are services handling sensitive data? Is the cluster multi-tenant? (For Voting App: single namespace, internal traffic only, development stage -> mTLS is nice-to-have, not required)
    2. "Do we need per-service observability?" - Evaluate: Can we debug issues with kubectl logs? How many services? (For Voting App: 5 services, kubectl logs sufficient for now, basic Prometheus would cover monitoring)
    3. "Do we have 10+ microservices?" - Count: 5 services. Below complexity threshold.
    4. "Can our team manage the overhead?" - Consider: mesh adds CRDs, sidecar injection, proxy debugging, certificate management
    Document answers in a structured format (markdown table or checklist).
  - **Task 3: Evaluate Alternatives**:
    For each service mesh benefit, identify a simpler alternative:
    - mTLS -> NetworkPolicy (Module 5) + pod security context
    - Observability -> `kubectl top pods` (already have Metrics Server from Module 2) + Prometheus (future)
    - Retries/Timeouts -> Application-level (client libraries) or Gateway API retry policies
    - Authorization -> RBAC + NetworkPolicies
    Create a comparison table: Benefit | With Mesh | Without Mesh | For Voting App
  - **Task 4: Write Your Decision Document**:
    Create a formal decision document using this template:
    ```
    Decision: [Adopt / Defer] Service Mesh for Voting App
    Date: [Today]
    Context: [1-2 sentences about the app]
    Decision Criteria: [List key factors]
    Evaluation: [Summary of Tasks 1-3]
    Decision: [Your choice with reasoning]
    Revisit When: [Conditions that would change this decision]
    ```
    Expected outcome: Most learners will conclude "Defer" for the Voting App at its current scale, with clear criteria for when to revisit.
  - **Challenge: Hands-On with Linkerd (Optional, +20 min)**:
    Install Linkerd CLI: `curl -sL https://linkerd.io/install | sh`
    Validate pre-checks: `linkerd check --pre`
    Install Linkerd on cluster: `linkerd install --crds | kubectl apply -f -` then `linkerd install | kubectl apply -f -`
    Wait for ready: `linkerd check`
    Inject Voting App: `kubectl get deploy -o yaml | linkerd inject - | kubectl apply -f -`
    Observe: `linkerd viz dashboard` (or `linkerd viz stat deploy` if dashboard not available)
    See mTLS in action: `linkerd viz edges deploy`
    See per-service metrics: request rate, success rate, latency per service
    Reflect: "Was this worth the setup? What did you learn that kubectl alone couldn't show you?"
    Clean up Linkerd: `linkerd uninject` the Voting App, then `linkerd uninstall | kubectl delete -f -`
    Note per research Pitfall 7: "If you get stuck on installation, don't worry. The evaluation tasks (1-4) are the core learning. Hands-on mesh experience comes with more practice."
- **Verification**:
  1. Communication map documents all 5 service-to-service connections
  2. Decision framework has all 4 questions answered with reasoning
  3. Alternatives table compares at least 4 mesh benefits with simpler options
  4. Decision document follows template with clear reasoning
  5. (If challenge completed) Linkerd dashboard shows service metrics
- **Cleanup**: Remove any Linkerd resources if installed. Redeploy clean Voting App from examples/ if mesh injection modified pods. Keep KIND cluster running.
- **Troubleshooting**:
  1. Linkerd install fails (pre-check failures - usually cluster version or resource constraints)
  2. Dashboard not accessible (use `linkerd viz stat` CLI alternative)
  3. Sidecar injection breaks Voting App (worker connection issues after proxy injection - restart pods)
- **Key Takeaways**: 5 points emphasizing decision-making skills over technology skills

This lab is unique: the primary deliverable is a DECISION, not a running system. The evaluation exercise builds critical thinking about when to adopt infrastructure tools.

**2. Create docs/section-4/quiz.md:**
Follow templates/quiz-template.md. Create 12 questions (7 MCQ, 3 scenario, 2 true/false).

Topics:
- What a service mesh provides (mTLS, observability, traffic management)
- Sidecar proxy pattern (how it intercepts traffic)
- Istio vs Linkerd tradeoffs (scenario: which to choose for small team?)
- When to adopt service mesh (scenario: 50+ services vs 5 services)
- Alternatives to service mesh (NetworkPolicy, Prometheus, etc.)
- mTLS purpose and implementation
- Service mesh operational overhead
- Decision framework application (scenario: new startup evaluating mesh)
- Resource overhead of sidecar proxies
- CNCF graduated vs incubating projects
- Service mesh and latency impact
- When NOT to use a service mesh (true/false: every production cluster needs mesh)

Scenario questions should present realistic situations requiring judgment (not just factual recall). Focus on decision-making skills: "Given this context, would you adopt a service mesh?"

Module metadata: Module: 4, Topic: Service Mesh, Question Count: 12
  </action>
  <verify>
    - `docs/section-4/03-lab.md` exists with all 8 sections
    - Lab has 4 main tasks + 1 optional challenge
    - Lab is evaluation-focused (decision document as deliverable, not running system)
    - Lab includes optional Linkerd hands-on challenge
    - Lab Task 4 has decision document template
    - `docs/section-4/quiz.md` has at least 12 questions
    - Quiz focuses on decision-making, not just technology facts
    - `npm run build` succeeds
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 4 lab provides a structured evaluation exercise with decision framework, communication mapping, alternatives comparison, and formal decision document. Optional Linkerd hands-on challenge. Quiz has 12 questions testing judgment about mesh adoption.</done>
</task>

</tasks>

<verification>
- Module 4 has 4 content files: 01-overview.mdx (updated), 02-reading.md, 03-lab.md, quiz.md
- Reading is 12-18 min with 2-3 Mermaid diagrams (traffic flow, decision tree, comparison)
- Lab follows 8-section template with 4 evaluation tasks + 1 optional challenge
- Lab is evaluation-focused (NOT implementation)
- Lab produces a decision document as primary deliverable
- Optional Linkerd challenge adds hands-on for interested learners
- Quiz has 12 questions focused on decision-making
- `npm run build` succeeds
</verification>

<success_criteria>
Module 4 is complete: service mesh decision framework explained with diagrams (12-18 min read), evaluation lab producing a decision document (40-50 min), optional Linkerd hands-on, and quiz testing judgment (12 questions). This completes Phase 3 covering Modules 0-4.
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-content/03-05-SUMMARY.md`
</output>
