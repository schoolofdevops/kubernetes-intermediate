---
phase: 04-advanced-content
plan: 04
type: execute
wave: 2
depends_on: ["04-03"]
files_modified:
  - docs/section-8/01-overview.mdx
  - docs/section-8/02-reading.md
  - docs/section-8/03-lab.md
  - docs/section-8/quiz.md
autonomous: true

must_haves:
  truths:
    - "Learner can read Module 8 content in 10-20 minutes and understand the operator pattern, reconciliation loop, and Kubebuilder workflow"
    - "Learner can follow the lab to scaffold, define API, implement controller logic, and test a VoteConfig operator"
    - "Learner can answer 12-15 quiz questions about operator concepts and best practices"
    - "Module 8 follows the School of DevOps learning sequence: scaffold, API, controller, build, deploy, enhance"
  artifacts:
    - path: "docs/section-8/02-reading.md"
      provides: "Operator pattern reading with reconciliation loop, Kubebuilder workflow"
      min_lines: 200
    - path: "docs/section-8/03-lab.md"
      provides: "VoteConfig operator lab following scaffold-to-deploy workflow"
      min_lines: 350
    - path: "docs/section-8/quiz.md"
      provides: "12-15 operator quiz questions"
      min_lines: 120
  key_links:
    - from: "docs/section-8/03-lab.md"
      to: "VoteConfig CRD from Module 7"
      via: "Operator reconciles VoteConfig resources created in Module 7"
      pattern: "VoteConfig"
    - from: "docs/section-8/02-reading.md"
      to: "docs/section-8/03-lab.md"
      via: "Next Steps info box linking to lab"
      pattern: "lab"
    - from: "docs/section-8/03-lab.md"
      to: "Kubebuilder"
      via: "Lab uses kubebuilder init and kubebuilder create api to scaffold operator"
      pattern: "kubebuilder"
---

<objective>
Create complete Module 8: Building Kubernetes Operators (Workflow) - teaching learners the operator pattern by building a VoteConfig operator that automates what Module 7 did manually (reconciling VoteConfig custom resources into ConfigMaps and triggering Deployment updates).

This module follows the School of DevOps learning sequence (per user instruction): scaffold, define API, implement controller, build image, deploy to cluster, enhance with validation. Uses Kubebuilder (not Operator SDK) as it is the official Kubernetes SIG project and more pedagogically transparent.

Purpose: Operators are the most powerful Kubernetes extension pattern. This module bridges the gap from "I can define a CRD" (Module 7) to "I can build a controller that acts on it." The VoteConfig operator is a beginner-friendly yet realistic use case.

Output: Complete Module 8 (overview, reading, lab, quiz) with 3-4 Mermaid diagrams and a comprehensive lab following the scaffold-to-deploy workflow.
</objective>

<execution_context>
@/Users/gshah/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gshah/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-content/04-RESEARCH.md
@.planning/phases/04-advanced-content/04-03-SUMMARY.md
@templates/content-template.md
@templates/lab-template.md
@templates/quiz-template.md
@templates/AUTHORING-GUIDE.md
@docs/section-8/01-overview.mdx
@docs/section-1/02-reading.md
@docs/section-1/03-lab.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Module 8 reading materials with overview update and Mermaid diagrams</name>
  <files>
    docs/section-8/01-overview.mdx
    docs/section-8/02-reading.md
  </files>
  <action>
**1. Update docs/section-8/01-overview.mdx:**
Replace placeholder content. Create proper module landing page:
- Title: "Module 8: Building Kubernetes Operators (Workflow)"
- Frontmatter: sidebar_position: 1, title: "Overview"
- Metadata block: Difficulty: Advanced, Estimated Time: 120 minutes (20 min reading + 75 min lab + 15 min quiz)
- "What You Will Learn" (5 items): The operator pattern and why it exists, Kubebuilder scaffolding workflow, defining custom API types in Go, implementing reconciliation logic (watch, compare, act), building and deploying an operator to a cluster
- "Prerequisites": Go 1.22+ installed, Kubebuilder installed, Docker installed (for building operator image), KIND cluster with VoteConfig CRD from Module 7 installed
- Brief overview: "In Module 7, you created VoteConfig custom resources and manually created ConfigMaps from them. Every time the VoteConfig changed, you had to manually update the ConfigMap. An operator automates this: it watches for VoteConfig changes and reconciles the desired state (what VoteConfig says) with the actual state (what exists in the cluster). This is the most powerful pattern in Kubernetes."
- Note: "This module walks through the operator WORKFLOW. The focus is on understanding the pattern and the development process. You will write real Go code, but the emphasis is on the reconciliation loop and Kubebuilder tooling, not on becoming a Go expert."

**2. Create docs/section-8/02-reading.md:**
Follow templates/content-template.md. Target: 15-20 minute read (~3000-4000 words). Conversational tone, no emojis.

Content structure:
- **Overview** (2-3 paragraphs): The gap between CRDs and automation. Module 7 created VoteConfig as a Kubernetes resource type. But resources without controllers are just data. An operator is a controller that watches custom resources and makes the cluster match the desired state. This is the same pattern Kubernetes uses internally: the Deployment controller watches Deployment resources and creates/updates ReplicaSets.
- **The Operator Pattern** section:
  - Definition: A Kubernetes controller that encodes operational knowledge (how to deploy, configure, heal) for a specific application
  - The reconciliation loop: Observe (what exists?) -> Compare (does it match desired state?) -> Act (create/update/delete to match)
  - Level-triggered vs edge-triggered: operators reconcile on state, not events. "If the operator crashes and restarts, it re-examines current state and reconciles. It does not need to replay events."
  - Include Mermaid diagram: Operator reconciliation loop (Watch CRD -> Reconcile() called -> Get desired state from CR spec -> Get actual state from cluster -> Compare -> Create/Update/Delete resources -> Update CR status -> Return)
  - Idempotency: Reconcile() can be called multiple times. Must produce same result. Never assume "this is the first time."
  - Real-world operators: cert-manager (manages TLS certificates), Prometheus Operator (manages monitoring), ArgoCD (manages GitOps deployments)
- **Kubebuilder: The Scaffolding Tool** section:
  - Official Kubernetes SIG project for building operators
  - What it generates: project structure, CRD types, controller boilerplate, RBAC manifests, Makefile, Dockerfile
  - Why Kubebuilder over Operator SDK: Kubebuilder is closer to upstream, simpler toolchain, Operator SDK wraps Kubebuilder anyway
  - Include Mermaid diagram: Kubebuilder project structure (main.go -> Manager -> Controller -> Reconciler, api/v1/types.go for CRD types, config/ for deployment manifests)
  - The workflow: init -> create api -> edit types -> edit controller -> make generate -> make manifests -> make run (local) -> make docker-build -> make deploy
- **The VoteConfig Operator** section:
  - What it does: watches VoteConfig resources, creates/updates ConfigMaps with vote option data, triggers vote Deployment rolling update when config changes, updates VoteConfig status
  - Include Mermaid sequence diagram: VoteConfig Reconciliation Flow (1. User creates VoteConfig -> 2. API Server stores in etcd -> 3. Controller detects change -> 4. Reconcile() called -> 5. Create/update ConfigMap -> 6. Annotate vote Deployment to trigger restart -> 7. Update VoteConfig status -> 8. Return)
  - Key code patterns (show Go snippets, explain each):
    - Fetching the resource: `r.Get(ctx, req.NamespacedName, &voteConfig)` with `IgnoreNotFound`
    - Creating owned resources: `ctrl.SetControllerReference()` for garbage collection
    - Updating status: `r.Status().Update()` with RetryOnConflict (from research Pitfall 3)
    - Setting up the manager: `ctrl.NewControllerManagedBy(mgr).For(&VoteConfig{}).Owns(&ConfigMap{}).Complete(r)`
  - RBAC markers: `// +kubebuilder:rbac:groups=...` comments that auto-generate Role manifests
- **Operator Development Best Practices** section:
  - Keep Reconcile() simple: orchestrate, delegate to helpers
  - Use status conditions: Ready, Degraded, Progressing (standard Kubernetes pattern)
  - Add finalizers for cleanup: when VoteConfig is deleted, also clean up ConfigMap
  - Log reconciliation decisions: every create/update/delete should be logged
  - Handle partial failures: requeue with backoff if something fails
  - Include Mermaid diagram: Controller-runtime components (Manager starts Controller, Controller has Reconciler, Client for API calls, Cache for reads)
- **When NOT to Write an Operator** section:
  - If a CronJob or simple script handles it, use that
  - If Helm hooks solve the lifecycle problem, use those
  - If the reconciliation logic is trivial, a ConfigMap controller might be overkill
  - "Write an operator when you need continuous reconciliation of complex state, not for one-time tasks."
- **Summary** with 5 bullet points
- **Further Reading**: Kubebuilder book, School of DevOps operator tutorial (https://kubernetes-tutorial.schoolofdevops.com/adv_operator_go/), controller-runtime docs
- Info admonition: "Next Steps - Build the VoteConfig operator from scratch in the lab"
  </action>
  <verify>
    - Both files exist and are non-empty
    - `npm run build` succeeds
    - 02-reading.md contains at least 3 Mermaid diagram code blocks (reconciliation loop, project structure, sequence diagram)
    - 02-reading.md word count is 3000-4000 words
    - Content references School of DevOps tutorial as inspiration
    - Content explains idempotency requirement
    - Content covers when NOT to write an operator
    - Content mentions Kubebuilder (not Operator SDK) per research recommendation
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 8 reading materials explain the operator pattern (reconciliation loop, Kubebuilder workflow, VoteConfig operator design, best practices) with 3-4 Mermaid diagrams targeting 15-20 min read time.</done>
</task>

<task type="auto">
  <name>Task 2: Create Module 8 lab and quiz</name>
  <files>
    docs/section-8/03-lab.md
    docs/section-8/quiz.md
  </files>
  <action>
**1. Create docs/section-8/03-lab.md:**
Follow templates/lab-template.md 8-section structure. Duration: 60-75 minutes. Follows School of DevOps learning sequence: scaffold, API, controller, build, deploy, enhance.

Title: "Lab: Building the VoteConfig Operator"

Inspiration: https://kubernetes-tutorial.schoolofdevops.com/adv_operator_go/ - Follow this learning sequence: scaffold, define API, implement controller, build, deploy, enhance. Use VoteConfig operator (better use case than StaticWebsite) - manages voting configurations via CRD.

- **Objectives** (6 items): Scaffold an operator project with Kubebuilder, define VoteConfig API types in Go, implement reconciliation logic that creates ConfigMaps from VoteConfig, test the operator locally with `make run`, build and deploy the operator to the cluster, enhance with validation webhook (challenge)
- **Prerequisites**: Go 1.22+ installed (`go version`), Kubebuilder installed (`kubebuilder version`), Docker installed (`docker version`), KIND cluster with VoteConfig CRD from Module 7 (or will be generated fresh by Kubebuilder)
- **Setup**:
  - Verify Go: `go version` (must be 1.22+)
  - Install Kubebuilder if needed:
    ```bash
    curl -L -o kubebuilder "https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)"
    chmod +x kubebuilder && sudo mv kubebuilder /usr/local/bin/
    ```
  - Verify: `kubebuilder version`
  - Ensure KIND cluster is running: `kubectl get nodes`
  - Create working directory: `mkdir -p ~/voteconfig-operator && cd ~/voteconfig-operator`

- **Tasks** (6 tasks, follows School of DevOps sequence):
  - **Task 1: Scaffold the Operator Project**:
    Step 1: Initialize the project:
    ```bash
    cd ~/voteconfig-operator
    kubebuilder init --domain example.com --repo github.com/example/voteconfig-operator
    ```
    Step 2: Explore the generated structure: main.go, Makefile, Dockerfile, config/ directory
    Step 3: Explain key files:
    - main.go: entry point, creates Manager, starts controllers
    - Makefile: targets for generate, manifests, build, deploy
    - config/: Kustomize manifests for deploying the operator
    - Dockerfile: multi-stage build for operator image
    Step 4: Create the VoteConfig API:
    ```bash
    kubebuilder create api --group voting --version v1 --kind VoteConfig --resource --controller
    ```
    Step 5: Explore what was generated: api/v1/voteconfig_types.go, internal/controller/voteconfig_controller.go, config/crd/
    Step 6: Run `make generate` and `make manifests` to see code generation in action
    Step 7: Verify the generated CRD: `cat config/crd/bases/voting.example.com_voteconfigs.yaml`

  - **Task 2: Define the VoteConfig API**:
    Step 1: Edit api/v1/voteconfig_types.go - replace the generated Spec and Status with:
    ```go
    // VoteOption represents a single voting choice
    type VoteOption struct {
        ID    string `json:"id"`
        Label string `json:"label"`
        Color string `json:"color,omitempty"`
    }

    // VoteConfigSpec defines the desired state of VoteConfig
    type VoteConfigSpec struct {
        Options      []VoteOption `json:"options"`
        Title        string       `json:"title,omitempty"`
        ResultsTitle string       `json:"resultsTitle,omitempty"`
    }

    // VoteConfigStatus defines the observed state of VoteConfig
    type VoteConfigStatus struct {
        ConfigMapRef string      `json:"configMapRef,omitempty"`
        LastUpdated  metav1.Time `json:"lastUpdated,omitempty"`
    }
    ```
    Step 2: Add Kubebuilder markers above VoteConfig struct:
    ```go
    // +kubebuilder:object:root=true
    // +kubebuilder:subresource:status
    // +kubebuilder:printcolumn:name="ConfigMap",type=string,JSONPath=`.status.configMapRef`
    // +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
    ```
    Step 3: Run `make generate` (updates deep-copy functions)
    Step 4: Run `make manifests` (regenerates CRD YAML with new schema)
    Step 5: Inspect the generated CRD: verify it includes VoteOption fields, status subresource
    Step 6: Install the CRD: `make install` (applies CRD to cluster)
    Step 7: Verify: `kubectl get crd voteconfigs.voting.example.com`

  - **Task 3: Implement the Reconcile Logic**:
    Step 1: Edit internal/controller/voteconfig_controller.go
    Step 2: Add RBAC markers (comments that generate Role manifests):
    ```go
    // +kubebuilder:rbac:groups=voting.example.com,resources=voteconfigs,verbs=get;list;watch;create;update;patch;delete
    // +kubebuilder:rbac:groups=voting.example.com,resources=voteconfigs/status,verbs=get;update;patch
    // +kubebuilder:rbac:groups="",resources=configmaps,verbs=get;list;watch;create;update;patch;delete
    // +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;update;patch
    ```
    Step 3: Implement Reconcile() function (provide the complete code from research Example 5):
    - Fetch VoteConfig resource (handle not-found for deletion)
    - Generate ConfigMap data from VoteConfig spec (marshal options to JSON)
    - Create or update ConfigMap (check if exists, create or update)
    - Set owner reference on ConfigMap (for garbage collection)
    - Annotate vote Deployment to trigger rolling update
    - Update VoteConfig status (configMapRef, lastUpdated)
    Step 4: Implement helper function generateConfigMapData()
    Step 5: Update SetupWithManager() to watch ConfigMaps owned by VoteConfig:
    ```go
    func (r *VoteConfigReconciler) SetupWithManager(mgr ctrl.Manager) error {
        return ctrl.NewControllerManagedBy(mgr).
            For(&votingv1.VoteConfig{}).
            Owns(&corev1.ConfigMap{}).
            Complete(r)
    }
    ```
    Step 6: Run `make generate && make manifests` to regenerate RBAC manifests
    Step 7: Verify the code compiles: `go build ./...`

  - **Task 4: Test the Operator Locally**:
    Step 1: Deploy the base Voting App to cluster (if not already running):
    ```bash
    kubectl create namespace voting-app --dry-run=client -o yaml | kubectl apply -f -
    kubectl apply -f examples/voting-app/ -n voting-app  # Or deploy base manifests
    ```
    Step 2: Run operator locally: `make run`
    Step 3: Operator output should show controller starting and watching for VoteConfig resources
    Step 4: In a SEPARATE terminal, create a VoteConfig:
    ```bash
    cat <<EOF | kubectl apply -f -
    apiVersion: voting.example.com/v1
    kind: VoteConfig
    metadata:
      name: cats-vs-dogs
      namespace: voting-app
    spec:
      title: "Cats vs Dogs"
      resultsTitle: "Current Results"
      options:
      - id: "a"
        label: "Cats"
        color: "#FF6B6B"
      - id: "b"
        label: "Dogs"
        color: "#4ECDC4"
    EOF
    ```
    Step 5: Watch operator logs (first terminal) - should see: "Created ConfigMap", "Triggered vote Deployment rolling update"
    Step 6: Verify ConfigMap was created: `kubectl get configmap cats-vs-dogs-config -n voting-app -o yaml`
    Step 7: Verify status was updated: `kubectl get voteconfig cats-vs-dogs -n voting-app -o yaml` (check status.configMapRef)
    Step 8: Test update: edit the VoteConfig (change title), watch operator reconcile again
    Step 9: Test deletion: `kubectl delete voteconfig cats-vs-dogs -n voting-app`, verify ConfigMap is automatically deleted (owner reference)
    Step 10: Stop the operator (Ctrl+C)

  - **Task 5: Build and Deploy the Operator to the Cluster**:
    Step 1: Build the operator image:
    ```bash
    make docker-build IMG=voteconfig-operator:v0.1.0
    ```
    Step 2: Load the image into KIND (since KIND can't pull from local Docker):
    ```bash
    kind load docker-image voteconfig-operator:v0.1.0 --name voting-app
    ```
    Step 3: Deploy to cluster:
    ```bash
    make deploy IMG=voteconfig-operator:v0.1.0
    ```
    Step 4: Verify operator pod is running:
    ```bash
    kubectl get pods -n voteconfig-operator-system
    ```
    Step 5: Check operator logs:
    ```bash
    kubectl logs -f deployment/voteconfig-operator-controller-manager -n voteconfig-operator-system
    ```
    Step 6: Create a VoteConfig and verify the operator (running in-cluster now) reconciles it
    Step 7: The operator is now self-contained in the cluster: no local process needed

  - **Task 6 (Challenge): Add Owner Reference and Finalizer**:
    Step 1: Add a finalizer to VoteConfig that cleans up any external resources (for learning, just log a message):
    ```go
    const finalizerName = "voting.example.com/finalizer"
    ```
    Step 2: In Reconcile(), check if resource is being deleted (DeletionTimestamp is set)
    Step 3: If deleting and has finalizer: perform cleanup, remove finalizer
    Step 4: If not deleting and missing finalizer: add finalizer
    Step 5: Rebuild, reload into KIND, redeploy
    Step 6: Test: create VoteConfig, delete it, watch operator logs show cleanup steps
    Step 7: Explain: "Finalizers ensure cleanup runs even if the user force-deletes. This is critical for operators managing external resources (databases, cloud services)."

- **Verification**:
  1. Operator project compiles: `go build ./...` succeeds
  2. CRD is installed: `kubectl get crd voteconfigs.voting.example.com`
  3. Operator pod is running: `kubectl get pods -n voteconfig-operator-system`
  4. Creating VoteConfig creates ConfigMap automatically
  5. Updating VoteConfig updates ConfigMap and triggers Deployment restart
  6. Deleting VoteConfig cleans up ConfigMap (owner reference)

- **Cleanup**: Undeploy the operator: `make undeploy`. Keep the CRD if desired. Delete the operator namespace. The ~/voteconfig-operator directory contains the full project for reference.

- **Troubleshooting**:
  1. "object has been modified" error (use RetryOnConflict for status updates - research Pitfall 3)
  2. RBAC errors in operator logs (check RBAC markers match resources used in controller)
  3. CRD not generating correctly (run `make generate && make manifests` after any types.go change)
  4. Image not found in KIND (must `kind load docker-image` after building)
  5. Controller not reconciling (check For/Owns setup in SetupWithManager, verify watches are correct)

- **Key Takeaways**: 5 points emphasizing the scaffold-to-deploy workflow, reconciliation pattern, and when operators add value

**2. Create docs/section-8/quiz.md:**
Follow templates/quiz-template.md. Create 14 questions (8 MCQ, 4 scenario, 2 true/false).

Topics:
- Operator pattern definition (controller + CRD + operational knowledge)
- Reconciliation loop: what triggers Reconcile()? (level-triggered, not edge-triggered)
- Idempotency requirement (scenario: what happens if Reconcile() is called twice?)
- Kubebuilder vs Operator SDK (what is the relationship?)
- RBAC markers purpose (auto-generate Role manifests from code comments)
- Owner references for garbage collection (scenario: what happens when parent is deleted?)
- Status subresource: why separate from spec? (concurrent update safety)
- Controller-runtime components: Manager, Controller, Reconciler
- RetryOnConflict pattern (scenario: operator gets "object modified" error, what to do?)
- Finalizers: when and why (true/false: finalizers prevent deletion until cleanup runs)
- When NOT to write an operator (true/false: every CRD needs an operator)
- VoteConfig reconciliation (scenario: user changes VoteConfig spec, what should happen?)
- `make generate` vs `make manifests` (what each produces)
- SetupWithManager: For() vs Owns() (what each watches)

Module metadata: Module: 8, Topic: Building Kubernetes Operators (Workflow), Question Count: 14
  </action>
  <verify>
    - `docs/section-8/03-lab.md` exists with all 8 sections
    - Lab has 6 tasks (scaffold, API, controller, test, deploy, challenge)
    - Lab follows School of DevOps sequence: scaffold -> API -> controller -> build -> deploy -> enhance
    - Lab uses Kubebuilder (not Operator SDK) per research recommendation
    - Lab includes complete Go code for Reconcile() function
    - Lab references VoteConfig CRD from Module 7
    - `docs/section-8/quiz.md` has at least 14 questions
    - `npm run build` succeeds
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 8 lab walks learners through building the VoteConfig operator: scaffold with Kubebuilder, define API types, implement reconciliation logic, test locally, build and deploy to cluster. Quiz has 14 questions testing operator concepts and best practices.</done>
</task>

</tasks>

<verification>
- Module 8 has 4 content files: 01-overview.mdx (updated), 02-reading.md, 03-lab.md, quiz.md
- Reading is 15-20 min with 3-4 Mermaid diagrams (reconciliation loop, project structure, sequence diagram, controller-runtime)
- Lab follows 8-section template with 6 tasks following School of DevOps sequence
- Lab builds on Module 7's VoteConfig CRD
- Lab uses Kubebuilder (not Operator SDK) per research recommendation
- Lab includes complete Go code for controller
- Quiz has 14 questions in correct format
- `npm run build` succeeds
</verification>

<success_criteria>
Module 8 is complete: operator pattern explained with diagrams (15-20 min read), hands-on lab building VoteConfig operator from scratch following scaffold-to-deploy workflow (60-75 min), and quiz testing operator knowledge (14 questions). The VoteConfig operator automates what Module 7 did manually.
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-content/04-04-SUMMARY.md`
</output>
