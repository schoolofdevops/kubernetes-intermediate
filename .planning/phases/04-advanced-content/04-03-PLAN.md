---
phase: 04-advanced-content
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/section-7/01-overview.mdx
  - docs/section-7/02-reading.md
  - docs/section-7/03-lab.md
  - docs/section-7/quiz.md
autonomous: true

must_haves:
  truths:
    - "Learner can read Module 7 content in 10-20 minutes and understand CRD concepts, API extension, schema validation, and status subresources"
    - "Learner can follow the lab to create the VoteConfig CRD with OpenAPI validation and create custom resources"
    - "Learner can answer 12-15 quiz questions about CRD concepts and API extension"
    - "Module 7 creates the VoteConfig CRD that Module 8 will build an operator for"
  artifacts:
    - path: "docs/section-7/02-reading.md"
      provides: "CRD concepts reading with API extension, schema validation"
      min_lines: 180
    - path: "docs/section-7/03-lab.md"
      provides: "Hands-on CRD creation lab with 4 tasks"
      min_lines: 250
    - path: "docs/section-7/quiz.md"
      provides: "12-15 CRD quiz questions"
      min_lines: 120
  key_links:
    - from: "docs/section-7/03-lab.md"
      to: "VoteConfig CRD"
      via: "Lab creates the VoteConfig CRD that Module 8 operator will reconcile"
      pattern: "voteconfigs.voting.example.com"
    - from: "docs/section-7/02-reading.md"
      to: "docs/section-7/03-lab.md"
      via: "Next Steps info box linking to lab"
      pattern: "lab"
---

<objective>
Create complete Module 7: Extending Kubernetes with CRDs - teaching learners to extend the Kubernetes API with Custom Resource Definitions. The module uses the VoteConfig CRD as the use case: a Kubernetes-native way to configure the Voting App's vote options (which options appear, colors, titles) instead of using raw ConfigMaps.

Purpose: CRDs are the foundation of the Kubernetes extension model. Understanding how to define custom APIs unlocks Operators (Module 8), Helm CRD patterns, and the entire CNCF ecosystem of controllers. VoteConfig is a pedagogically sound use case - simple enough to understand, realistic enough to demonstrate real patterns.

Output: Complete Module 7 (overview, reading, lab, quiz) with 2-3 Mermaid diagrams and a lab creating the VoteConfig CRD with validation.
</objective>

<execution_context>
@/Users/gshah/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gshah/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-content/04-RESEARCH.md
@templates/content-template.md
@templates/lab-template.md
@templates/quiz-template.md
@templates/AUTHORING-GUIDE.md
@docs/section-7/01-overview.mdx
@docs/section-1/02-reading.md
@docs/section-1/03-lab.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Module 7 reading materials with overview update and Mermaid diagrams</name>
  <files>
    docs/section-7/01-overview.mdx
    docs/section-7/02-reading.md
  </files>
  <action>
**1. Update docs/section-7/01-overview.mdx:**
Replace placeholder content. Create proper module landing page:
- Title: "Module 7: Extending Kubernetes with CRDs"
- Frontmatter: sidebar_position: 1, title: "Overview"
- Metadata block: Difficulty: Intermediate-Advanced, Estimated Time: 80 minutes (15 min reading + 45 min lab + 15 min quiz)
- "What You Will Learn" (5 items): How CRDs extend the Kubernetes API, designing a custom resource schema with OpenAPI v3 validation, creating and managing custom resources with kubectl, status subresources for reporting resource state, how CRDs set the foundation for Operators (Module 8)
- "Prerequisites": KIND cluster running, kubectl installed, familiarity with Kubernetes resource model (pods, deployments, services)
- Brief overview: "Every kubectl command you have used so far (get pods, get deployments, get services) works because those resource types are built into the Kubernetes API. But what if you could define your OWN resource types? What if `kubectl get voteconfigs` worked just like `kubectl get pods`? That is exactly what Custom Resource Definitions give you."

**2. Create docs/section-7/02-reading.md:**
Follow templates/content-template.md. Target: 12-18 minute read (~2500-3500 words). Conversational tone, no emojis.

Content structure:
- **Overview** (2-3 paragraphs): The limitation of ConfigMaps. The Voting App's configuration (which vote options appear, their colors, titles) is currently stored in environment variables or ConfigMaps. ConfigMaps are generic key-value stores with no validation, no custom columns in kubectl output, and no standardized lifecycle. CRDs solve this by creating a purpose-built Kubernetes API for your application's configuration.
- **What is a CRD?** section:
  - Simple definition: A way to teach Kubernetes new resource types
  - Before CRDs: only built-in types (Pods, Services, etc.)
  - After CRDs: any custom type you define (VoteConfig, Database, Certificate, etc.)
  - The entire CNCF ecosystem uses CRDs: cert-manager (Certificate), Prometheus (ServiceMonitor), Istio (VirtualService), Gateway API (HTTPRoute)
  - Once a CRD is installed, kubectl just works: get, describe, create, delete, watch
  - Include Mermaid diagram: Kubernetes API extension architecture showing API Server -> CRD Controller -> stores in etcd, alongside built-in resources
- **CRD Anatomy** section:
  - The CRD resource itself is a "recipe" that tells the API server how to handle new resources
  - Key fields: group (voting.example.com), versions (v1), scope (Namespaced vs Cluster), names (plural, singular, kind, shortNames)
  - Naming convention: plural.group (voteconfigs.voting.example.com)
  - Include full VoteConfig CRD YAML (from research Example 4) with inline annotations explaining each section
  - The spec.versions.schema.openAPIV3Schema is where validation lives
- **Schema Validation** section:
  - OpenAPI v3 schema: types, required fields, patterns, enums, min/max
  - Why validation matters: without it, API server accepts any YAML, operators crash on bad input
  - VoteConfig validation rules:
    - options: array, minItems 2 (need at least 2 things to vote on), maxItems 10
    - option.id: string, pattern ^[a-z]$ (single lowercase letter)
    - option.label: string, minLength 1, maxLength 50
    - option.color: string, pattern ^#[0-9A-Fa-f]{6}$ (hex color)
  - Testing validation: submit invalid resource, API server rejects with clear error
  - Caution admonition: "A CRD without validation is like a REST API that accepts any JSON. It works until someone sends garbage and your controller crashes."
- **Status Subresource** section:
  - spec vs status: spec is what you WANT (desired state), status is what you HAVE (observed state)
  - Enabling status subresource: subresources.status: {} in CRD definition
  - Why separate: spec updates and status updates go through different API endpoints, preventing accidental overwrites
  - Status fields for VoteConfig: configMapRef (generated ConfigMap name), lastUpdated (timestamp), conditions (Ready/Degraded)
  - This is what Module 8's operator will update
- **Additional Printer Columns** section:
  - Custom columns in `kubectl get` output (like how `kubectl get pods` shows STATUS, READY, AGE)
  - jsonPath expressions to extract values from the resource
  - VoteConfig columns: Options count, ConfigMap reference, Age
  - Makes kubectl output useful for your custom types
- **Short Names** section:
  - Like how `kubectl get po` is short for `kubectl get pods`
  - VoteConfig shortName: `vc` -> `kubectl get vc`
- **The CRD Ecosystem** section:
  - Brief tour: cert-manager Certificate CRD, Prometheus ServiceMonitor, Gateway API HTTPRoute
  - CRDs are the building blocks; controllers/operators are the brains
  - "A CRD without a controller is like a form without anyone to process it. It stores data but does not act on it. Module 8 adds the controller."
- **Summary** with 5 bullet points
- **Further Reading**: K8s CRD docs, API extension overview
- Info admonition: "Next Steps - Create the VoteConfig CRD and custom resources in the lab"
  </action>
  <verify>
    - Both files exist and are non-empty
    - `npm run build` succeeds
    - 02-reading.md contains at least 2 Mermaid diagram code blocks (API extension architecture, VoteConfig schema structure)
    - 02-reading.md word count is 2500-3500 words
    - Content includes full VoteConfig CRD YAML with validation rules
    - Content explains spec vs status separation
    - Content mentions Module 8 operator will bring CRD to life
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 7 reading materials explain CRD concepts (API extension, schema validation, status subresource, printer columns) with 2-3 Mermaid diagrams and the VoteConfig CRD as central example, targeting 12-18 min read time.</done>
</task>

<task type="auto">
  <name>Task 2: Create Module 7 lab and quiz</name>
  <files>
    docs/section-7/03-lab.md
    docs/section-7/quiz.md
  </files>
  <action>
**1. Create docs/section-7/03-lab.md:**
Follow templates/lab-template.md 8-section structure. Duration: 40-50 minutes.

Title: "Lab: Creating the VoteConfig Custom Resource"

- **Objectives** (5 items): Define a CustomResourceDefinition with OpenAPI v3 schema validation, install the CRD and verify API registration, create VoteConfig custom resources using kubectl, test schema validation by submitting invalid resources, manually bridge VoteConfig to ConfigMap (the manual process Module 8 automates)
- **Prerequisites**: KIND cluster running, kubectl installed
- **Setup**:
  - Ensure cluster is running: `kubectl get nodes`
  - Create namespace: `kubectl create namespace voting-app` (if not exists)
  - Deploy base Voting App if not already running
  - Create working directory: `mkdir -p ~/voteconfig-crd`

- **Tasks** (4 tasks + 1 challenge):
  - **Task 1: Define the VoteConfig CRD**:
    Step 1: Create voteconfig-crd.yaml with the full CRD definition (from research Example 4):
    - apiVersion: apiextensions.k8s.io/v1
    - kind: CustomResourceDefinition
    - metadata.name: voteconfigs.voting.example.com
    - group: voting.example.com
    - versions: v1 with full OpenAPI v3 schema
    - Validation rules: options (array, minItems 2, maxItems 10), option.id (pattern ^[a-z]$), option.label (minLength 1, maxLength 50), option.color (pattern ^#[0-9A-Fa-f]{6}$)
    - Status subresource enabled
    - Additional printer columns: Options, ConfigMap, Age
    - Short names: vc
    - Scope: Namespaced
    Step 2: Walk through each section of the CRD YAML, explaining what it does
    Step 3: Emphasize the naming convention: metadata.name MUST be plural.group (voteconfigs.voting.example.com)

  - **Task 2: Install CRD and Verify Registration**:
    Step 1: Apply the CRD: `kubectl apply -f voteconfig-crd.yaml`
    Step 2: Verify CRD is registered: `kubectl get crd voteconfigs.voting.example.com`
    Step 3: Check API resources: `kubectl api-resources | grep voteconfig` - should show VoteConfig with shortname vc
    Step 4: Try kubectl completion: `kubectl get voteconfigs` (should return "No resources found" - CRD is registered but no instances exist)
    Step 5: Try short name: `kubectl get vc` (same result, confirms short name works)
    Step 6: Explain: "The API server now knows about VoteConfig. It is as real as any built-in resource."

  - **Task 3: Create Custom Resources and Test Validation**:
    Step 1: Create cats-vs-dogs.yaml (valid VoteConfig from research example):
    ```yaml
    apiVersion: voting.example.com/v1
    kind: VoteConfig
    metadata:
      name: cats-vs-dogs
      namespace: voting-app
    spec:
      title: "Cats vs Dogs - The Ultimate Showdown"
      resultsTitle: "And the winner is..."
      options:
      - id: "a"
        label: "Cats"
        color: "#FF6B6B"
      - id: "b"
        label: "Dogs"
        color: "#4ECDC4"
    ```
    Step 2: Apply: `kubectl apply -f cats-vs-dogs.yaml`
    Step 3: Verify: `kubectl get vc -n voting-app` (should show custom printer columns)
    Step 4: Describe: `kubectl describe voteconfig cats-vs-dogs -n voting-app` (full resource details)
    Step 5: Create a second VoteConfig (pizza-vs-tacos.yaml) with different options to show multiple resources
    Step 6: Test validation - create invalid-config.yaml with deliberately bad data:
    ```yaml
    apiVersion: voting.example.com/v1
    kind: VoteConfig
    metadata:
      name: bad-config
      namespace: voting-app
    spec:
      options:
      - id: "toolong"    # Violates pattern ^[a-z]$ (more than one char)
        label: ""         # Violates minLength 1
        color: "notahex"  # Violates hex pattern
    ```
    Step 7: Apply invalid config: `kubectl apply -f invalid-config.yaml` - should FAIL with validation errors
    Step 8: Show and explain each validation error message
    Step 9: Fix the invalid config and reapply successfully

  - **Task 4: Bridge VoteConfig to ConfigMap (Manual Process)**:
    Step 1: Explain: "Right now, VoteConfig stores data but nothing ACTS on it. In Module 8, we build an operator to automate this. For now, we will do it manually to understand what the operator will do."
    Step 2: Read VoteConfig data: `kubectl get voteconfig cats-vs-dogs -n voting-app -o jsonpath='{.spec.options}' | python3 -m json.tool`
    Step 3: Create a ConfigMap from VoteConfig data:
    ```bash
    kubectl create configmap vote-options \
      --from-literal=option_a="Cats" \
      --from-literal=option_b="Dogs" \
      --from-literal=title="Cats vs Dogs - The Ultimate Showdown" \
      -n voting-app
    ```
    Step 4: Verify ConfigMap: `kubectl get configmap vote-options -n voting-app -o yaml`
    Step 5: Explain the manual pain: "Every time you change VoteConfig, you would need to manually update the ConfigMap. This is exactly what an operator automates. In Module 8, we build a controller that watches for VoteConfig changes and updates ConfigMaps automatically."
    Step 6: Update VoteConfig (change a label or color), show that ConfigMap is now STALE (out of sync)
    Step 7: Emphasize: "This manual synchronization is error-prone and does not scale. Operators solve this by implementing a reconciliation loop."

  - **Challenge: Create a Multi-Version CRD**:
    Add a v2 version to VoteConfig that includes a new field (maxVotesPerUser: integer):
    - Add v2 to the versions array in the CRD with storage: false (v1 remains storage version)
    - v2 schema includes all v1 fields plus maxVotesPerUser
    - Apply updated CRD
    - Create a v2 resource with the new field
    - Verify both v1 and v2 resources coexist
    - Explain: "In production, you version CRDs just like REST APIs. Old clients use v1, new clients use v2."

- **Verification**:
  1. CRD is registered: `kubectl get crd voteconfigs.voting.example.com` shows it
  2. Custom resources created: `kubectl get vc -n voting-app` shows at least 2
  3. Validation works: invalid resources are rejected
  4. Short name works: `kubectl get vc` returns results
  5. ConfigMap manually created from VoteConfig data

- **Cleanup**: Keep the CRD and VoteConfig resources installed. Module 8 builds the operator that reconciles these. Delete only the manually-created ConfigMap: `kubectl delete configmap vote-options -n voting-app`

- **Troubleshooting**:
  1. CRD name mismatch: metadata.name must be plural.group (voteconfigs.voting.example.com)
  2. Schema validation too strict: test with valid data first, tighten gradually
  3. "resource already exists" error: use `kubectl apply` not `kubectl create` for updates
  4. Printer columns not showing: verify jsonPath expressions match actual resource structure

- **Key Takeaways**: 5 points emphasizing CRDs as API extension, validation importance, and the gap that operators fill

**2. Create docs/section-7/quiz.md:**
Follow templates/quiz-template.md. Create 13 questions (8 MCQ, 3 scenario, 2 true/false).

Topics:
- What CRDs do (extend Kubernetes API with custom types)
- CRD naming convention (plural.group)
- OpenAPI v3 schema purpose (validation)
- Required fields in CRD (group, versions, scope, names)
- Spec vs status distinction (desired state vs observed state)
- Status subresource purpose (separate update path)
- CRD scope: Namespaced vs Cluster
- Schema validation pattern (scenario: which pattern validates hex colors?)
- Additional printer columns purpose
- CRD without a controller (true/false: CRD alone automates reconciliation)
- Short names (what they enable)
- VoteConfig use case (scenario: design validation rules for vote options)
- Multi-version CRDs (scenario: how to add a field without breaking v1 clients)

Module metadata: Module: 7, Topic: Extending Kubernetes with CRDs, Question Count: 13
  </action>
  <verify>
    - `docs/section-7/03-lab.md` exists with all 8 sections
    - Lab has 4 main tasks + 1 challenge task
    - Lab creates VoteConfig CRD with full validation schema
    - Lab tests validation by submitting invalid resources
    - Lab includes manual CRD-to-ConfigMap bridge (setting up Module 8)
    - Lab cleanup keeps CRD installed for Module 8
    - `docs/section-7/quiz.md` has at least 13 questions
    - `npm run build` succeeds
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 7 lab walks learners through creating the VoteConfig CRD: defining schema, installing, creating resources, testing validation, and manually bridging to ConfigMap. Quiz has 13 questions testing CRD concepts. VoteConfig CRD is ready for Module 8 operator.</done>
</task>

</tasks>

<verification>
- Module 7 has 4 content files: 01-overview.mdx (updated), 02-reading.md, 03-lab.md, quiz.md
- Reading is 12-18 min with 2-3 Mermaid diagrams (API architecture, schema structure)
- Lab follows 8-section template with 4 tasks + 1 challenge
- Lab creates VoteConfig CRD with OpenAPI v3 validation
- Lab demonstrates manual CRD-to-ConfigMap process (Module 8 automates this)
- Lab cleanup preserves CRD for Module 8
- Quiz has 13 questions in correct format
- `npm run build` succeeds
</verification>

<success_criteria>
Module 7 is complete: CRD concepts explained with diagrams (12-18 min read), hands-on lab creating VoteConfig CRD with validation (40-50 min), and quiz testing API extension knowledge (13 questions). VoteConfig CRD is installed and ready for Module 8's operator.
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-content/04-03-SUMMARY.md`
</output>
