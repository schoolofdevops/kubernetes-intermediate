---
phase: 04-advanced-content
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/section-6/01-overview.mdx
  - docs/section-6/02-reading.md
  - docs/section-6/03-lab.md
  - docs/section-6/quiz.md
autonomous: true

must_haves:
  truths:
    - "Learner can read Module 6 content in 10-20 minutes and understand Helm chart structure, templates, values, dependencies, and lifecycle hooks"
    - "Learner can follow the lab to progressively convert the Voting App from raw manifests to a Helm chart with dependencies and lifecycle hooks"
    - "Learner can answer 12-15 quiz questions about Helm concepts and best practices"
    - "Module 6 teaches Helm 3 with awareness of Helm 4 evolution"
  artifacts:
    - path: "docs/section-6/02-reading.md"
      provides: "Helm concepts reading with chart structure, templates, dependencies"
      min_lines: 200
    - path: "docs/section-6/03-lab.md"
      provides: "Progressive Helm chart creation lab with 5 tasks"
      min_lines: 300
    - path: "docs/section-6/quiz.md"
      provides: "12-15 Helm quiz questions"
      min_lines: 120
  key_links:
    - from: "docs/section-6/03-lab.md"
      to: "helm create"
      via: "Lab starts by scaffolding a chart with helm create"
      pattern: "helm create"
    - from: "docs/section-6/02-reading.md"
      to: "docs/section-6/03-lab.md"
      via: "Next Steps info box linking to lab"
      pattern: "lab"
---

<objective>
Create complete Module 6: Helm for Real-World Applications - teaching learners to convert the Voting App from raw Kubernetes manifests into a maintainable Helm chart. The module follows a progressive approach: start with one component (vote service), templatize it, add dependencies (redis from Bitnami), build an umbrella chart for the full app, and add lifecycle hooks.

Purpose: Helm is the de facto standard for Kubernetes package management. This module transforms learners from "I write YAML files" to "I build reusable, parameterized, versionable deployment packages." The progressive approach avoids the common mistake of trying to templatize everything at once.

Output: Complete Module 6 (overview, reading, lab, quiz) with 3 Mermaid diagrams and a comprehensive lab building a Helm chart progressively.
</objective>

<execution_context>
@/Users/gshah/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gshah/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-content/04-RESEARCH.md
@templates/content-template.md
@templates/lab-template.md
@templates/quiz-template.md
@templates/AUTHORING-GUIDE.md
@docs/section-6/01-overview.mdx
@docs/section-1/02-reading.md
@docs/section-1/03-lab.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Module 6 reading materials with overview update and Mermaid diagrams</name>
  <files>
    docs/section-6/01-overview.mdx
    docs/section-6/02-reading.md
  </files>
  <action>
**1. Update docs/section-6/01-overview.mdx:**
Replace placeholder content. Create proper module landing page:
- Title: "Module 6: Writing Helm Charts"
- Frontmatter: sidebar_position: 1, title: "Overview"
- Metadata block: Difficulty: Intermediate, Estimated Time: 100 minutes (15 min reading + 60 min lab + 15 min quiz)
- "What You Will Learn" (5 items): Helm chart structure and conventions, Go template syntax for Kubernetes manifests, values.yaml patterns for parameterized deployments, chart dependencies for reusing community charts, lifecycle hooks for deployment automation
- "Prerequisites": Helm 3 installed (`brew install helm` or curl installer), KIND cluster running with Voting App (or willingness to deploy fresh), familiarity with Voting App architecture
- Brief overview: "You have been writing raw YAML manifests. They work, but deploying the Voting App to a new environment means editing every file. What if you could deploy the entire stack with one command, customize it with a single values file, and version your deployments? That is what Helm provides."

**2. Create docs/section-6/02-reading.md:**
Follow templates/content-template.md. Target: 12-18 minute read (~2500-3500 words). Conversational tone, no emojis.

Content structure:
- **Overview** (2-3 paragraphs): The problem with raw manifests. 5 deployments, 5 services, configmaps, secrets - each a separate file. Deploying to staging vs production means editing image tags, replica counts, resource limits across every file. Helm solves this with charts: packages of templated Kubernetes manifests with configurable values.
- **What is Helm?** section:
  - Package manager for Kubernetes (like apt for Ubuntu, brew for macOS)
  - Three big concepts: Charts (packages), Releases (instances of charts), Repositories (chart storage)
  - Helm 3 (current): client-only, no server-side Tiller (Helm 2's security issue)
  - Info admonition: "Helm 4 was released in late 2025 with OCI registry support as default. This course teaches Helm 3 concepts which are identical. The tooling details (chart repos vs OCI registries) are the main difference."
- **Chart Structure** section:
  - Include Mermaid diagram: chart directory tree with annotations explaining each file's purpose (Chart.yaml, values.yaml, templates/, charts/, NOTES.txt, _helpers.tpl)
  - Chart.yaml: metadata (name, version, appVersion, description, dependencies)
  - values.yaml: default configuration (what users override)
  - templates/: Go template files that render to Kubernetes manifests
  - _helpers.tpl: reusable template snippets (fullname, labels, selectors)
  - NOTES.txt: post-install instructions shown to user
  - Chart version vs app version: chart changes independently from the application
- **Templates and Values** section:
  - Go template basics: {{ .Values.replicaCount }}, {{ .Release.Name }}, {{ .Chart.AppVersion }}
  - Template functions: default, quote, nindent, toYaml, include
  - Whitespace control: {{- and -}} for clean YAML output
  - Include YAML example: vote-deployment.yaml template (from research Example 3)
  - Include matching values.yaml snippet showing what gets substituted
  - Include Mermaid diagram: template rendering flow (values.yaml + template files -> helm template -> rendered manifests -> kubectl apply)
  - Anti-pattern: over-templatization. "Do NOT make everything a value. Template what varies between environments (replicas, images, resources). Hardcode what should be consistent (port names, health check paths)."
  - Debugging: `helm template .` renders locally, `helm lint` checks syntax
- **Dependencies** section:
  - Using community charts (bitnami/redis, bitnami/postgresql) instead of maintaining your own
  - Chart.yaml dependencies block with version locking (exact versions, not ranges)
  - `helm dependency update` fetches charts into charts/ directory
  - Condition flags: redis.enabled allows toggling dependencies
  - Include Mermaid diagram: umbrella chart dependency graph (voting-app -> vote, result, worker subcharts + redis, postgresql from Bitnami)
  - Caution: dependency version conflicts (from research Pitfall 7). Lock versions. Test with `helm dep list`.
- **Lifecycle Hooks** section:
  - pre-install, post-install, pre-upgrade, post-upgrade, pre-delete, post-delete
  - Use cases: database migrations (pre-upgrade), cache warming (post-install), cleanup jobs (pre-delete)
  - Hook weight for ordering multiple hooks
  - Brief YAML example: pre-install Job for database schema initialization
  - Hooks are Jobs/Pods that run to completion before/after the main install/upgrade
- **Summary** with 5 bullet points
- **Further Reading**: Helm docs, chart best practices, artifact hub
- Info admonition: "Next Steps - Build a Helm chart for the Voting App in the lab"
  </action>
  <verify>
    - Both files exist and are non-empty
    - `npm run build` succeeds
    - 02-reading.md contains at least 3 Mermaid diagram code blocks (chart structure, template flow, dependency graph)
    - 02-reading.md word count is 2500-3500 words
    - Content mentions Helm 4 evolution
    - Content warns about over-templatization anti-pattern
    - Content covers dependency version locking
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 6 reading materials explain Helm concepts (chart structure, templates, values, dependencies, hooks) with 3 Mermaid diagrams, practical YAML examples, and anti-patterns targeting 12-18 min read time.</done>
</task>

<task type="auto">
  <name>Task 2: Create Module 6 lab and quiz</name>
  <files>
    docs/section-6/03-lab.md
    docs/section-6/quiz.md
  </files>
  <action>
**1. Create docs/section-6/03-lab.md:**
Follow templates/lab-template.md 8-section structure. Duration: 50-60 minutes. Progressive chart building approach.

Title: "Lab: Helm-ifying the Voting App"

- **Objectives** (5 items): Scaffold a Helm chart with `helm create`, templatize Kubernetes manifests with values, add chart dependencies for redis and postgresql, build an umbrella chart deploying the entire Voting App, add a pre-install lifecycle hook for database setup
- **Prerequisites**: Helm 3 installed (`helm version` shows v3.x), KIND cluster running, familiarity with Voting App YAML structure
- **Setup**:
  - Ensure Helm is installed: `helm version` (if not: `curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash`)
  - Ensure KIND cluster is running with at least 1 worker: `kubectl get nodes`
  - Create a fresh namespace for Helm deployments: `kubectl create namespace helm-voting-app`
  - Create a working directory: `mkdir -p ~/voting-app-chart && cd ~/voting-app-chart`

- **Tasks** (5 tasks + 1 challenge):
  - **Task 1: Create Your First Chart (Vote Service)**:
    Step 1: Scaffold chart: `helm create voting-app`. Explore the generated structure. Explain each file.
    Step 2: Clean the templates/ directory: remove default templates (deployment.yaml, service.yaml, etc.) that helm create generates. We will write our own.
    Step 3: Create templates/vote-deployment.yaml - start with the raw vote Deployment manifest from examples/, then replace: image with {{ .Values.vote.image.repository }}:{{ .Values.vote.image.tag }}, replicas with {{ .Values.vote.replicaCount }}
    Step 4: Create templates/vote-service.yaml - templatize the vote Service (port from values).
    Step 5: Update values.yaml with vote section: replicaCount: 2, image.repository: schoolofdevops/vote, image.tag: v1, service.type: ClusterIP, service.port: 80
    Step 6: Test rendering: `helm template ./voting-app` - verify output is valid Kubernetes YAML
    Step 7: Install the chart: `helm install voting-app ./voting-app -n helm-voting-app`
    Step 8: Verify: `kubectl get pods -n helm-voting-app` shows vote pods running
    Note: Use schoolofdevops/vote:v1 image consistently per project convention (D018).

  - **Task 2: Templatize with Helpers and Labels**:
    Step 1: Edit templates/_helpers.tpl - define voting-app.fullname, voting-app.labels, voting-app.selectorLabels helpers
    Step 2: Update vote-deployment.yaml to use {{ include "voting-app.labels" . | nindent 4 }} for metadata labels and {{ include "voting-app.selectorLabels" . | nindent 6 }} for selectors
    Step 3: Add resource limits to values.yaml and template: {{ toYaml .Values.vote.resources | nindent 10 }}
    Step 4: Add the result service templates (result-deployment.yaml, result-service.yaml) using same helpers
    Step 5: Add the worker deployment template (worker-deployment.yaml, no service - worker has no incoming traffic)
    Step 6: Update values.yaml with result and worker sections
    Step 7: Upgrade the release: `helm upgrade voting-app ./voting-app -n helm-voting-app`
    Step 8: Verify all three app components running: `kubectl get pods -n helm-voting-app`
    Step 9: Lint the chart: `helm lint ./voting-app` (should pass with no errors)

  - **Task 3: Add Chart Dependencies (Redis and PostgreSQL)**:
    Step 1: Edit Chart.yaml to add dependencies:
    ```yaml
    dependencies:
    - name: redis
      version: "18.19.4"
      repository: https://charts.bitnami.com/bitnami
      condition: redis.enabled
    - name: postgresql
      version: "15.5.38"
      repository: https://charts.bitnami.com/bitnami
      condition: postgresql.enabled
    ```
    Step 2: Add dependency configuration to values.yaml:
    ```yaml
    redis:
      enabled: true
      auth:
        enabled: false
    postgresql:
      enabled: true
      auth:
        username: postgres
        password: postgres
        database: votes
    ```
    Step 3: Run `helm dependency update ./voting-app` - downloads charts to charts/ directory
    Step 4: Verify: `helm dep list ./voting-app` shows both dependencies with status "ok"
    Step 5: Remove old redis/postgresql templates (if any) - dependencies handle them now
    Step 6: Update worker template environment variables to point to dependency service names (redis-master, postgresql)
    Step 7: Upgrade: `helm upgrade voting-app ./voting-app -n helm-voting-app`
    Step 8: Verify all pods (vote, result, worker, redis, postgresql) running: `kubectl get pods -n helm-voting-app`
    Note: Exact Bitnami chart versions may differ. Use `helm search repo bitnami/redis --versions | head -5` to find current versions. Lock to exact version, not range.

  - **Task 4: Deploy to Multiple Environments**:
    Step 1: Create values-staging.yaml with lower replicas and resources:
    ```yaml
    vote:
      replicaCount: 1
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
    ```
    Step 2: Create values-production.yaml with higher replicas and resources:
    ```yaml
    vote:
      replicaCount: 3
      resources:
        limits:
          cpu: 500m
          memory: 512Mi
    ```
    Step 3: Deploy staging: `helm install voting-staging ./voting-app -n staging --create-namespace -f values-staging.yaml`
    Step 4: Deploy production: `helm install voting-prod ./voting-app -n production --create-namespace -f values-production.yaml`
    Step 5: Compare: `kubectl get pods -n staging` (1 vote replica) vs `kubectl get pods -n production` (3 replicas)
    Step 6: Show release management: `helm list --all-namespaces` shows all releases
    Step 7: Clean up extra namespaces: `helm uninstall voting-staging -n staging && helm uninstall voting-prod -n production`

  - **Task 5: Add Lifecycle Hook**:
    Step 1: Create templates/pre-install-job.yaml - a Job that runs before install:
    ```yaml
    apiVersion: batch/v1
    kind: Job
    metadata:
      name: {{ include "voting-app.fullname" . }}-db-init
      annotations:
        "helm.sh/hook": pre-install
        "helm.sh/hook-weight": "-5"
        "helm.sh/hook-delete-policy": hook-succeeded
    spec:
      template:
        spec:
          containers:
          - name: db-init
            image: postgres:15
            command: ["sh", "-c", "echo 'Database initialization would run here'"]
          restartPolicy: Never
    ```
    Step 2: Explain hook annotations: hook type, weight (ordering), delete policy
    Step 3: Uninstall and reinstall to trigger pre-install hook: `helm uninstall voting-app -n helm-voting-app && helm install voting-app ./voting-app -n helm-voting-app`
    Step 4: Check hook job ran: `kubectl get jobs -n helm-voting-app` (should show completed db-init job or it was deleted by hook-delete-policy)
    Step 5: Explain when hooks are useful: database migrations, cache priming, health checks

  - **Challenge: Chart Testing**:
    Create templates/tests/test-connection.yaml:
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: {{ include "voting-app.fullname" . }}-test
      annotations:
        "helm.sh/hook": test
    spec:
      containers:
      - name: wget
        image: busybox
        command: ['wget', '--spider', 'http://{{ include "voting-app.fullname" . }}-vote:80']
      restartPolicy: Never
    ```
    Run: `helm test voting-app -n helm-voting-app`
    Verify test pod succeeds (vote service is reachable).

- **Verification**:
  1. `helm list -n helm-voting-app` shows deployed release
  2. All pods running: vote, result, worker, redis, postgresql
  3. `helm template ./voting-app` renders valid YAML with no errors
  4. `helm lint ./voting-app` passes
  5. Voting App is functional: cast vote via port-forward, see result

- **Cleanup**: Keep the Helm release deployed. Future modules may reference it. Chart source in ~/voting-app-chart/ can be used as reference.

- **Troubleshooting**:
  1. Template rendering errors (use `helm template --debug` to see raw template output)
  2. Dependency not found (run `helm repo add bitnami https://charts.bitnami.com/bitnami` first)
  3. Values not taking effect (check YAML path: .Values.vote.image.tag not .Values.image.tag)
  4. Release stuck in pending-install (check for failed hooks, use `helm uninstall --no-hooks`)

- **Key Takeaways**: 5 points

**2. Create docs/section-6/quiz.md:**
Follow templates/quiz-template.md. Create 13 questions (8 MCQ, 3 scenario, 2 true/false).

Topics:
- Chart.yaml fields: version vs appVersion distinction
- values.yaml purpose and override mechanism
- Template function: what does {{ .Values.replicaCount | default 1 }} do?
- _helpers.tpl purpose (reusable template snippets)
- `helm template` vs `helm install` difference (dry-run vs actual deploy)
- Chart dependency management (scenario: how to add redis as dependency?)
- Over-templatization anti-pattern (true/false: should every field be a value?)
- Hook types: pre-install, post-upgrade, etc. (which hook for database migrations?)
- `helm lint` purpose (static analysis)
- Helm release vs chart distinction
- Values file precedence (--set > -f values-prod.yaml > values.yaml)
- Debugging template errors (scenario: error on line 23 of rendered output)
- Helm 3 vs Helm 2 key difference (no Tiller)

Module metadata: Module: 6, Topic: Writing Helm Charts, Question Count: 13
  </action>
  <verify>
    - `docs/section-6/03-lab.md` exists with all 8 sections
    - Lab has 5 main tasks + 1 challenge task
    - Lab progressively builds chart (single component -> templates -> dependencies -> multi-env -> hooks)
    - Lab uses schoolofdevops/vote:v1 image
    - Lab includes `helm lint` and `helm template` verification steps
    - `docs/section-6/quiz.md` has at least 13 questions
    - `npm run build` succeeds
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 6 lab walks learners through progressive Helm chart creation: scaffold, templatize, add dependencies, multi-environment deploy, and lifecycle hooks. Quiz has 13 questions testing Helm concepts and best practices.</done>
</task>

</tasks>

<verification>
- Module 6 has 4 content files: 01-overview.mdx (updated), 02-reading.md, 03-lab.md, quiz.md
- Reading is 12-18 min with 3 Mermaid diagrams (chart structure, template flow, dependency graph)
- Lab follows 8-section template with 5 tasks + 1 challenge
- Lab progressively builds from single component to full umbrella chart
- Lab uses Helm 3 with awareness of Helm 4
- Quiz has 13 questions in correct format
- `npm run build` succeeds
</verification>

<success_criteria>
Module 6 is complete: Helm concepts explained with diagrams (12-18 min read), hands-on lab building a Voting App Helm chart progressively (50-60 min), and quiz testing Helm knowledge (13 questions). The Voting App is now deployable as a single `helm install` command.
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-content/04-02-SUMMARY.md`
</output>
