---
phase: 03-core-content
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - docs/section-3/01-overview.mdx
  - docs/section-3/02-reading.md
  - docs/section-3/03-lab.md
  - docs/section-3/quiz.md
autonomous: true

must_haves:
  truths:
    - "Learner can read Module 3 content in 10-20 minutes and understand Gateway API resource model (GatewayClass, Gateway, HTTPRoute)"
    - "Learner can follow the lab to install a Gateway controller, create Gateway and HTTPRoute resources, and route traffic to Voting App services"
    - "Learner can explain the difference between Ingress API and Gateway API"
    - "Learner can answer 12-15 quiz questions about Gateway API routing and migration"
  artifacts:
    - path: "docs/section-3/02-reading.md"
      provides: "Gateway API concepts with resource hierarchy and routing"
      min_lines: 180
    - path: "docs/section-3/03-lab.md"
      provides: "Gateway API lab with Contour, HTTPRoutes, and traffic management"
      min_lines: 250
    - path: "docs/section-3/quiz.md"
      provides: "12-15 Gateway API quiz questions"
      min_lines: 120
  key_links:
    - from: "docs/section-3/03-lab.md"
      to: "examples/voting-app/"
      via: "Deploys fresh Voting App for Gateway API routing"
      pattern: "vote|result"
    - from: "docs/section-3/02-reading.md"
      to: "docs/section-3/03-lab.md"
      via: "Next Steps info box"
      pattern: "lab"
---

<objective>
Create complete Module 3: Gateway API - teaching learners to route traffic to Kubernetes services using the modern Gateway API (replacing Ingress). Learners install a Gateway controller (Contour), create GatewayClass/Gateway/HTTPRoute resources, implement path-based routing for the Voting App, and explore traffic splitting for canary deployments.

Purpose: Gateway API is the future of Kubernetes traffic management. This module teaches modern routing patterns that replace the Ingress API, showing role-based resource ownership (platform team manages Gateway, app team manages HTTPRoutes).

Output: Complete Module 3 (overview, reading, lab, quiz) with 3 Mermaid diagrams and a lab using Contour as the Gateway implementation.
</objective>

<execution_context>
@/Users/gshah/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gshah/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-content/03-CONTEXT.md
@.planning/phases/03-core-content/03-RESEARCH.md
@.planning/phases/03-core-content/03-01-SUMMARY.md
@templates/content-template.md
@templates/lab-template.md
@templates/quiz-template.md
@templates/AUTHORING-GUIDE.md
@docs/section-3/01-overview.mdx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Module 3 reading materials with overview update and Mermaid diagrams</name>
  <files>
    docs/section-3/01-overview.mdx
    docs/section-3/02-reading.md
  </files>
  <action>
**1. Update docs/section-3/01-overview.mdx:**
Replace placeholder. Create proper module landing page:
- Title: "Module 3: Gateway API"
- Frontmatter: sidebar_position: 1, title: "Overview"
- Metadata: Difficulty: Intermediate, Estimated Time: 95 minutes (15 min reading + 55 min lab + 15 min quiz)
- "What You Will Learn" (5 items): Gateway API resource model, installing a Gateway controller, creating HTTPRoutes for the Voting App, path-based and header-based routing, Ingress to Gateway API migration concepts
- "Prerequisites": Module 0 completed (KIND cluster running), kubectl and kind installed. This module starts with a fresh Voting App deployment (not carrying forward from Module 2).
- Overview: "So far, you've been accessing the Voting App through NodePort services and port-forwarding. In production, you need proper HTTP routing - path-based routing, host-based routing, header matching, and traffic splitting. Gateway API is Kubernetes' modern answer to traffic management."

**2. Create docs/section-3/02-reading.md:**
Follow templates/content-template.md. Target: 12-18 minute read (~2500-3500 words). Conversational tone, no emojis.

Content structure:
- **Overview** (2-3 paragraphs): The traffic management problem. NodePort and port-forward don't scale. Ingress was the first answer, but it had limitations (single resource, limited routing rules, implementation-dependent annotations). Gateway API is the modern replacement with explicit resource separation and richer routing.
- **Why Gateway API Replaced Ingress** section:
  - Problems with Ingress: everything in one resource, controller-specific annotations, limited expressiveness
  - Gateway API design principles: role-oriented (infrastructure provider, cluster operator, app developer), typed routing (HTTPRoute, TLSRoute, GRPCRoute), portable (no vendor annotations)
  - Include Mermaid diagram: Ingress vs Gateway API comparison - side by side showing Ingress (single resource, annotations) vs Gateway API (GatewayClass -> Gateway -> HTTPRoute hierarchy)
  - Info admonition: "Gateway API reached v1.0 GA in 2023. While Ingress is still supported, Gateway API is the recommended path for new deployments."
- **The Gateway API Resource Model** section:
  - **GatewayClass**: Defines the controller implementation (like StorageClass for storage). Managed by infrastructure provider.
  - **Gateway**: Configures listeners (ports, protocols, hostnames). Managed by cluster operator.
  - **HTTPRoute**: Defines routing rules (path matching, header matching, backend references). Managed by app developer.
  - Include Mermaid graph diagram: Resource hierarchy showing GatewayClass -> Gateway -> HTTPRoute -> Service -> Pods, with role labels on each tier
  - Explain role-based ownership: "Platform teams manage the Gateway (what ports are open), app teams manage HTTPRoutes (where their traffic goes). Clean separation of concerns."
  - YAML examples for each resource (brief, conceptual, not full Voting App yet - that's for the lab)
- **HTTPRoute Routing Rules** section:
  - Path matching (PathPrefix, Exact)
  - Header matching (exact, regex)
  - Backend references (service + port + weight)
  - Traffic splitting (weight-based for canary deployments)
  - Include YAML example: HTTPRoute with path-based routing for vote and result (from research Example 6)
  - Include Mermaid flowchart: HTTPRoute matching logic (request comes in -> match host? -> match path? -> match headers? -> route to backend with weight)
- **Namespace Considerations** section:
  - HTTPRoute and Gateway must be in same namespace (or use ReferenceGrant)
  - Caution admonition: "Gateway API has strict namespace rules. If your HTTPRoute doesn't attach, check namespaces first." (from research Pitfall 5)
- **Gateway Controller Implementations** section:
  - Brief overview: Contour, NGINX Gateway Fabric, Istio, Envoy Gateway
  - Course uses Contour (simplest to install, well-documented for Gateway API)
  - Tip: "The beauty of Gateway API is portability - your HTTPRoutes work with any compliant controller."
- **Summary** with 5 bullet points
- **Further Reading**: Gateway API official docs, migration guide, Contour docs
- Info admonition: "Next Steps - Time to route traffic to your Voting App using Gateway API in the lab"
  </action>
  <verify>
    - Both files exist and are non-empty
    - `npm run build` succeeds
    - 02-reading.md contains at least 3 Mermaid diagram code blocks
    - 02-reading.md word count is 2500-3500 words
    - Content covers Ingress vs Gateway API comparison
    - Content explains namespace considerations (Pitfall 5)
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 3 reading materials explain Gateway API with resource hierarchy, Ingress comparison, HTTPRoute routing rules, and namespace considerations. 3 Mermaid diagrams. Targeting 12-18 min read time.</done>
</task>

<task type="auto">
  <name>Task 2: Create Module 3 lab and quiz</name>
  <files>
    docs/section-3/03-lab.md
    docs/section-3/quiz.md
  </files>
  <action>
**1. Create docs/section-3/03-lab.md:**
Follow templates/lab-template.md 8-section structure. Duration: 50-55 minutes. Starts with fresh Voting App deployment (does not carry forward Module 2 autoscaling state).

Title: "Lab: Routing Traffic with Gateway API"

- **Objectives** (5 items): Install Contour as Gateway API controller, create a Gateway with HTTP listener, configure HTTPRoutes for vote and result services, implement path-based routing, explore traffic splitting for canary deployments
- **Prerequisites**: KIND cluster running (from Module 0), kubectl installed, basic understanding of Services and Pods
- **Setup**:
  - Fresh deployment: "Module 3 starts with a clean slate. If you have autoscaling resources from Module 2, clean them up first."
  - Redeploy base Voting App from examples/ (kubectl apply -f for all base YAMLs)
  - Verify app is running with `kubectl get pods`
  - Install Gateway API CRDs: `kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml` (from research)
  - Verify CRDs installed: `kubectl get crd | grep gateway`
- **Tasks** (5 tasks + 1 challenge):
  - **Task 1: Install Contour Gateway Controller**:
    Install Contour using quickstart: `kubectl apply -f https://projectcontour.io/quickstart/contour-gateway.yaml` (from research).
    Wait for Contour to be ready: `kubectl wait --for=condition=available --timeout=300s deployment -n projectcontour contour`.
    Verify GatewayClass exists: `kubectl get gatewayclass`.
    Explain: "Contour registers a GatewayClass named 'contour'. This tells Kubernetes that Contour can process Gateway resources."
  - **Task 2: Create a Gateway**:
    Create a Gateway resource with an HTTP listener on port 80.
    Include full YAML with GatewayClass reference, listener config, and allowed routes.
    Apply and verify: `kubectl get gateway`, check conditions with `kubectl describe gateway`.
    Show the Gateway address (for KIND, this will be a local address or require port-forward to the Contour envoy service).
    Explain the role separation: "As a cluster operator, you've defined that HTTP traffic on port 80 is accepted. App developers can now create HTTPRoutes to route their traffic."
  - **Task 3: Create HTTPRoutes for Vote and Result**:
    Create HTTPRoute for vote service: hostname vote.example.com, path prefix /, backend vote:80.
    Create HTTPRoute for result service: hostname result.example.com, path prefix /, backend result:80.
    Apply both. Verify with `kubectl get httproute`.
    Check route attachment: `kubectl describe httproute vote-route` - look for "Accepted: True" and "ResolvedRefs: True".
    Test access: port-forward to Contour envoy service, use curl with Host header:
    `curl -H "Host: vote.example.com" http://localhost:8080`
    `curl -H "Host: result.example.com" http://localhost:8080`
    Explain: "Each service gets its own hostname. The Gateway handles the routing based on the Host header."
  - **Task 4: Path-Based Routing**:
    Create a combined HTTPRoute with path-based routing:
    - /vote -> vote service
    - /result -> result service
    Apply and test with curl: `curl http://localhost:8080/vote`, `curl http://localhost:8080/result`.
    Explain path matching types: PathPrefix vs Exact.
    Show how to verify which backend handled the request.
  - **Task 5: Traffic Splitting (Canary Pattern)**:
    Create a second vote deployment (vote-canary) with a different version tag or environment variable.
    Create an HTTPRoute with weighted backends: 90% to vote, 10% to vote-canary.
    Test by sending multiple requests and observing distribution.
    Explain: "Traffic splitting enables canary deployments - gradually shifting traffic to a new version while monitoring for errors."
    Show header-based routing alternative: route requests with X-Canary: true header to canary (from research Example 6).
  - **Challenge: Namespace Isolation**:
    Create a new namespace (team-b). Try to create an HTTPRoute in team-b referencing the Gateway in default namespace.
    Observe failure: route doesn't attach.
    Fix by creating a ReferenceGrant in default namespace allowing team-b to reference the Gateway.
    Verify route now attaches.
    Learning: "Gateway API enforces namespace boundaries by default. ReferenceGrant explicitly allows cross-namespace references."
- **Verification**:
  1. `kubectl get gatewayclass` shows contour class
  2. `kubectl get gateway` shows gateway with Address assigned
  3. `kubectl get httproute` shows all routes with Accepted=True
  4. curl with Host headers returns correct services
  5. Traffic splitting distributes requests approximately 90/10
  6. Voting App is fully functional through Gateway
- **Cleanup**: Clean up Gateway resources and Contour. Keep KIND cluster running.
  "Module 4 (Service Mesh Decision) is an evaluation module. Clean up Gateway API resources:
  `kubectl delete httproute --all`, `kubectl delete gateway --all`.
  Optionally keep Contour installed for future reference."
- **Troubleshooting**:
  1. HTTPRoute not attaching (namespace mismatch - from research Pitfall 5)
  2. Contour envoy service not getting external IP (expected in KIND, use port-forward instead)
  3. Gateway shows "Programmed: False" (GatewayClass not matching, Contour not ready)
- **Key Takeaways**: 5 points

Include all kubectl commands with expected output. Show curl examples with Host headers.

**2. Create docs/section-3/quiz.md:**
Follow templates/quiz-template.md. Create 12 questions (7 MCQ, 3 scenario, 2 true/false).

Topics:
- GatewayClass vs Gateway vs HTTPRoute roles
- Role-based resource ownership (who manages what?)
- Ingress vs Gateway API differences (scenario: migration decision)
- HTTPRoute path matching types (PathPrefix vs Exact)
- Namespace isolation and ReferenceGrant
- Traffic splitting weights (scenario: calculate traffic distribution)
- Backend references and port configuration
- Gateway listener configuration
- Why Gateway API is more portable than Ingress
- Contour/NGINX Gateway/Istio as implementations
- Header-based routing use cases
- Debugging HTTPRoute attachment failures (scenario: route not working, why?)

Module metadata: Module: 3, Topic: Gateway API, Question Count: 12
  </action>
  <verify>
    - `docs/section-3/03-lab.md` exists with all 8 sections
    - Lab has 5 tasks + 1 challenge
    - Lab starts with fresh Voting App deployment (not carry-forward)
    - Lab installs Contour and Gateway API CRDs
    - Lab includes traffic splitting with weighted backends
    - `docs/section-3/quiz.md` has at least 12 questions
    - `npm run build` succeeds
    - No emojis, all code blocks have language tags
  </verify>
  <done>Module 3 lab walks learners through Contour installation, Gateway/HTTPRoute creation, path-based routing, and traffic splitting with the Voting App. Quiz has 12 questions testing Gateway API concepts.</done>
</task>

</tasks>

<verification>
- Module 3 has 4 content files: 01-overview.mdx (updated), 02-reading.md, 03-lab.md, quiz.md
- Reading is 12-18 min with 3 Mermaid diagrams
- Lab follows 8-section template with 5 tasks + 1 challenge
- Lab starts fresh (not carrying forward Module 2 state)
- Lab uses Contour as Gateway controller per research recommendation
- Lab includes traffic splitting (canary pattern)
- Quiz has 12 questions in correct format
- `npm run build` succeeds
</verification>

<success_criteria>
Module 3 is complete: Gateway API concepts explained with resource hierarchy diagrams (12-18 min read), hands-on lab installing Contour and routing Voting App traffic (50-55 min), and quiz testing understanding (12 questions).
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-content/03-04-SUMMARY.md`
</output>
